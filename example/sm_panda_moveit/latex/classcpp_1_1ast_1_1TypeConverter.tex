\hypertarget{classcpp_1_1ast_1_1TypeConverter}{}\section{cpp.\+ast.\+Type\+Converter Class Reference}
\label{classcpp_1_1ast_1_1TypeConverter}\index{cpp.\+ast.\+Type\+Converter@{cpp.\+ast.\+Type\+Converter}}


Inheritance diagram for cpp.\+ast.\+Type\+Converter\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{classcpp_1_1ast_1_1TypeConverter__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for cpp.\+ast.\+Type\+Converter\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{classcpp_1_1ast_1_1TypeConverter__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_ae6e75773d6722cdbb96d510a49cb633a}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, \hyperlink{classcpp_1_1ast_1_1TypeConverter_abb739f15c6cd0800e07c086c2b30833e}{namespace\+\_\+stack})
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_aa6ea82e40cd30e5dfcd471ff144a19cf}{To\+Type} (self, tokens)
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_a7c9d20d107c2bc0eb80afdf04957825f}{Declaration\+To\+Parts} (self, parts, needs\+\_\+name\+\_\+removed)
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_aeaf27fb1890f65d7216703df610b46d5}{To\+Parameters} (self, tokens)
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_a7e4d429131d9d5742ec44c78b61beb87}{Create\+Return\+Type} (self, return\+\_\+type\+\_\+seq)
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_a7b5244be5a0caedd769ae866f8a182aa}{Get\+Template\+Indices} (self, names)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classcpp_1_1ast_1_1TypeConverter_abb739f15c6cd0800e07c086c2b30833e}{namespace\+\_\+stack}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classcpp_1_1ast_1_1TypeConverter_adcf38788abb48f32f4a63eb091b3d53a}{\+\_\+\+Get\+Template\+End} (self, tokens, start)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 458 of file ast.\+py.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_ae6e75773d6722cdbb96d510a49cb633a}\label{classcpp_1_1ast_1_1TypeConverter_ae6e75773d6722cdbb96d510a49cb633a}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{namespace\+\_\+stack }\end{DoxyParamCaption})}



Definition at line 460 of file ast.\+py.


\begin{DoxyCode}
460     \textcolor{keyword}{def }\_\_init\_\_(self, namespace\_stack):
461         self.namespace\_stack = namespace\_stack
462 
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_adcf38788abb48f32f4a63eb091b3d53a}\label{classcpp_1_1ast_1_1TypeConverter_adcf38788abb48f32f4a63eb091b3d53a}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!\+\_\+\+Get\+Template\+End@{\+\_\+\+Get\+Template\+End}}
\index{\+\_\+\+Get\+Template\+End@{\+\_\+\+Get\+Template\+End}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{\+\_\+\+Get\+Template\+End()}{\_GetTemplateEnd()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+\_\+\+Get\+Template\+End (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{tokens,  }\item[{}]{start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 463 of file ast.\+py.



Referenced by cpp.\+ast.\+Type\+Converter.\+Declaration\+To\+Parts(), and cpp.\+ast.\+Type\+Converter.\+To\+Type().


\begin{DoxyCode}
463     \textcolor{keyword}{def }\_GetTemplateEnd(self, tokens, start):
464         count = 1
465         end = start
466         \textcolor{keywordflow}{while} 1:
467             token = tokens[end]
468             end += 1
469             \textcolor{keywordflow}{if} token.name == \textcolor{stringliteral}{'<'}:
470                 count += 1
471             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{'>'}:
472                 count -= 1
473                 \textcolor{keywordflow}{if} count == 0:
474                     \textcolor{keywordflow}{break}
475         \textcolor{keywordflow}{return} tokens[start:end-1], end
476 
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_adcf38788abb48f32f4a63eb091b3d53a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_a7e4d429131d9d5742ec44c78b61beb87}\label{classcpp_1_1ast_1_1TypeConverter_a7e4d429131d9d5742ec44c78b61beb87}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!Create\+Return\+Type@{Create\+Return\+Type}}
\index{Create\+Return\+Type@{Create\+Return\+Type}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{Create\+Return\+Type()}{CreateReturnType()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+Create\+Return\+Type (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{return\+\_\+type\+\_\+seq }\end{DoxyParamCaption})}



Definition at line 652 of file ast.\+py.



References cpp.\+ast.\+Type\+Converter.\+Declaration\+To\+Parts().


\begin{DoxyCode}
652     \textcolor{keyword}{def }CreateReturnType(self, return\_type\_seq):
653         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} return\_type\_seq:
654             \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}
655         start = return\_type\_seq[0].start
656         end = return\_type\_seq[-1].end
657         \_, name, templated\_types, modifiers, default, other\_tokens = \(\backslash\)
658            self.DeclarationToParts(return\_type\_seq, \textcolor{keyword}{False})
659         names = [n.name \textcolor{keywordflow}{for} n \textcolor{keywordflow}{in} other\_tokens]
660         reference = \textcolor{stringliteral}{'&'} \textcolor{keywordflow}{in} names
661         pointer = \textcolor{stringliteral}{'*'} \textcolor{keywordflow}{in} names
662         array = \textcolor{stringliteral}{'['} \textcolor{keywordflow}{in} names
663         \textcolor{keywordflow}{return} Type(start, end, name, templated\_types, modifiers,
664                     reference, pointer, array)
665 
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_a7e4d429131d9d5742ec44c78b61beb87_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_a7c9d20d107c2bc0eb80afdf04957825f}\label{classcpp_1_1ast_1_1TypeConverter_a7c9d20d107c2bc0eb80afdf04957825f}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!Declaration\+To\+Parts@{Declaration\+To\+Parts}}
\index{Declaration\+To\+Parts@{Declaration\+To\+Parts}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{Declaration\+To\+Parts()}{DeclarationToParts()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+Declaration\+To\+Parts (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{parts,  }\item[{}]{needs\+\_\+name\+\_\+removed }\end{DoxyParamCaption})}



Definition at line 536 of file ast.\+py.



References cpp.\+ast.\+Type\+Converter.\+\_\+\+Get\+Template\+End(), and cpp.\+ast.\+Type\+Converter.\+To\+Type().



Referenced by cpp.\+ast.\+Type\+Converter.\+Create\+Return\+Type(), and cpp.\+ast.\+Type\+Converter.\+To\+Parameters().


\begin{DoxyCode}
536     \textcolor{keyword}{def }DeclarationToParts(self, parts, needs\_name\_removed):
537         name = \textcolor{keywordtype}{None}
538         default = []
539         \textcolor{keywordflow}{if} needs\_name\_removed:
540             \textcolor{comment}{# Handle default (initial) values properly.}
541             \textcolor{keywordflow}{for} i, t \textcolor{keywordflow}{in} enumerate(parts):
542                 \textcolor{keywordflow}{if} t.name == \textcolor{stringliteral}{'='}:
543                     default = parts[i+1:]
544                     name = parts[i-1].name
545                     \textcolor{keywordflow}{if} name == \textcolor{stringliteral}{']'} \textcolor{keywordflow}{and} parts[i-2].name == \textcolor{stringliteral}{'['}:
546                         name = parts[i-3].name
547                         i -= 1
548                     parts = parts[:i-1]
549                     \textcolor{keywordflow}{break}
550             \textcolor{keywordflow}{else}:
551                 \textcolor{keywordflow}{if} parts[-1].token\_type == tokenize.NAME:
552                     name = parts.pop().name
553                 \textcolor{keywordflow}{else}:
554                     \textcolor{comment}{# TODO(nnorwitz): this is a hack that happens for code like}
555                     \textcolor{comment}{# Register(Foo<T>); where it thinks this is a function call}
556                     \textcolor{comment}{# but it's actually a declaration.}
557                     name = \textcolor{stringliteral}{'???'}
558         modifiers = []
559         type\_name = []
560         other\_tokens = []
561         templated\_types = []
562         i = 0
563         end = len(parts)
564         \textcolor{keywordflow}{while} i < end:
565             p = parts[i]
566             \textcolor{keywordflow}{if} keywords.IsKeyword(p.name):
567                 modifiers.append(p.name)
568             \textcolor{keywordflow}{elif} p.name == \textcolor{stringliteral}{'<'}:
569                 templated\_tokens, new\_end = self.\_GetTemplateEnd(parts, i+1)
570                 templated\_types = self.ToType(templated\_tokens)
571                 i = new\_end - 1
572                 \textcolor{comment}{# Don't add a spurious :: to data members being initialized.}
573                 next\_index = i + 1
574                 \textcolor{keywordflow}{if} next\_index < end \textcolor{keywordflow}{and} parts[next\_index].name == \textcolor{stringliteral}{'::'}:
575                     i += 1
576             \textcolor{keywordflow}{elif} p.name \textcolor{keywordflow}{in} (\textcolor{stringliteral}{'['}, \textcolor{stringliteral}{']'}, \textcolor{stringliteral}{'='}):
577                 \textcolor{comment}{# These are handled elsewhere.}
578                 other\_tokens.append(p)
579             \textcolor{keywordflow}{elif} p.name \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} (\textcolor{stringliteral}{'*'}, \textcolor{stringliteral}{'&'}, \textcolor{stringliteral}{'>'}):
580                 \textcolor{comment}{# Ensure that names have a space between them.}
581                 \textcolor{keywordflow}{if} (type\_name \textcolor{keywordflow}{and} type\_name[-1].token\_type == tokenize.NAME \textcolor{keywordflow}{and}
582                     p.token\_type == tokenize.NAME):
583                     type\_name.append(tokenize.Token(tokenize.SYNTAX, \textcolor{stringliteral}{' '}, 0, 0))
584                 type\_name.append(p)
585             \textcolor{keywordflow}{else}:
586                 other\_tokens.append(p)
587             i += 1
588         type\_name = \textcolor{stringliteral}{''}.join([t.name \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} type\_name])
589         \textcolor{keywordflow}{return} name, type\_name, templated\_types, modifiers, default, other\_tokens
590 
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_a7c9d20d107c2bc0eb80afdf04957825f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_a7c9d20d107c2bc0eb80afdf04957825f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_a7b5244be5a0caedd769ae866f8a182aa}\label{classcpp_1_1ast_1_1TypeConverter_a7b5244be5a0caedd769ae866f8a182aa}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!Get\+Template\+Indices@{Get\+Template\+Indices}}
\index{Get\+Template\+Indices@{Get\+Template\+Indices}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{Get\+Template\+Indices()}{GetTemplateIndices()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+Get\+Template\+Indices (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{names }\end{DoxyParamCaption})}



Definition at line 666 of file ast.\+py.


\begin{DoxyCode}
666     \textcolor{keyword}{def }GetTemplateIndices(self, names):
667         \textcolor{comment}{# names is a list of strings.}
668         start = names.index(\textcolor{stringliteral}{'<'})
669         end = len(names) - 1
670         \textcolor{keywordflow}{while} end > 0:
671             \textcolor{keywordflow}{if} names[end] == \textcolor{stringliteral}{'>'}:
672                 \textcolor{keywordflow}{break}
673             end -= 1
674         \textcolor{keywordflow}{return} start, end+1
675 
\end{DoxyCode}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_aeaf27fb1890f65d7216703df610b46d5}\label{classcpp_1_1ast_1_1TypeConverter_aeaf27fb1890f65d7216703df610b46d5}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!To\+Parameters@{To\+Parameters}}
\index{To\+Parameters@{To\+Parameters}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{To\+Parameters()}{ToParameters()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+To\+Parameters (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{tokens }\end{DoxyParamCaption})}



Definition at line 591 of file ast.\+py.



References cpp.\+ast.\+Type\+Converter.\+Declaration\+To\+Parts().


\begin{DoxyCode}
591     \textcolor{keyword}{def }ToParameters(self, tokens):
592         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} tokens:
593             \textcolor{keywordflow}{return} []
594 
595         result = []
596         name = type\_name = \textcolor{stringliteral}{''}
597         type\_modifiers = []
598         pointer = reference = array = \textcolor{keyword}{False}
599         first\_token = \textcolor{keywordtype}{None}
600         default = []
601 
602         \textcolor{keyword}{def }AddParameter(end):
603             \textcolor{keywordflow}{if} default:
604                 del default[0]  \textcolor{comment}{# Remove flag.}
605             parts = self.DeclarationToParts(type\_modifiers, \textcolor{keyword}{True})
606             (name, type\_name, templated\_types, modifiers,
607              unused\_default, unused\_other\_tokens) = parts
608             parameter\_type = Type(first\_token.start, first\_token.end,
609                                   type\_name, templated\_types, modifiers,
610                                   reference, pointer, array)
611             p = Parameter(first\_token.start, end, name,
612                           parameter\_type, default)
613             result.append(p)
614 
615         template\_count = 0
616         \textcolor{keywordflow}{for} s \textcolor{keywordflow}{in} tokens:
617             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} first\_token:
618                 first\_token = s
619             \textcolor{keywordflow}{if} s.name == \textcolor{stringliteral}{'<'}:
620                 template\_count += 1
621             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{'>'}:
622                 template\_count -= 1
623             \textcolor{keywordflow}{if} template\_count > 0:
624                 type\_modifiers.append(s)
625                 \textcolor{keywordflow}{continue}
626 
627             \textcolor{keywordflow}{if} s.name == \textcolor{stringliteral}{','}:
628                 AddParameter(s.start)
629                 name = type\_name = \textcolor{stringliteral}{''}
630                 type\_modifiers = []
631                 pointer = reference = array = \textcolor{keyword}{False}
632                 first\_token = \textcolor{keywordtype}{None}
633                 default = []
634             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{'*'}:
635                 pointer = \textcolor{keyword}{True}
636             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{'&'}:
637                 reference = \textcolor{keyword}{True}
638             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{'['}:
639                 array = \textcolor{keyword}{True}
640             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{']'}:
641                 \textcolor{keywordflow}{pass}  \textcolor{comment}{# Just don't add to type\_modifiers.}
642             \textcolor{keywordflow}{elif} s.name == \textcolor{stringliteral}{'='}:
643                 \textcolor{comment}{# Got a default value.  Add any value (None) as a flag.}
644                 default.append(\textcolor{keywordtype}{None})
645             \textcolor{keywordflow}{elif} default:
646                 default.append(s)
647             \textcolor{keywordflow}{else}:
648                 type\_modifiers.append(s)
649         AddParameter(tokens[-1].end)
650         \textcolor{keywordflow}{return} result
651 
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_aeaf27fb1890f65d7216703df610b46d5_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_aa6ea82e40cd30e5dfcd471ff144a19cf}\label{classcpp_1_1ast_1_1TypeConverter_aa6ea82e40cd30e5dfcd471ff144a19cf}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!To\+Type@{To\+Type}}
\index{To\+Type@{To\+Type}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{To\+Type()}{ToType()}}
{\footnotesize\ttfamily def cpp.\+ast.\+Type\+Converter.\+To\+Type (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert [Token,...] to [Class(...), ] useful for base classes.
For example, code like class Foo : public Bar<x, y> { ... };
the "Bar<x, y>" portion gets converted to an AST.

Returns:
  [Class(...), ...]
\end{DoxyVerb}
 

Definition at line 477 of file ast.\+py.



References cpp.\+ast.\+Type\+Converter.\+\_\+\+Get\+Template\+End(), and cpp.\+ast.\+Type\+Converter.\+To\+Type().



Referenced by cpp.\+ast.\+Type\+Converter.\+Declaration\+To\+Parts(), and cpp.\+ast.\+Type\+Converter.\+To\+Type().


\begin{DoxyCode}
477     \textcolor{keyword}{def }ToType(self, tokens):
478         \textcolor{stringliteral}{"""Convert [Token,...] to [Class(...), ] useful for base classes.}
479 \textcolor{stringliteral}{        For example, code like class Foo : public Bar<x, y> \{ ... \};}
480 \textcolor{stringliteral}{        the "Bar<x, y>" portion gets converted to an AST.}
481 \textcolor{stringliteral}{}
482 \textcolor{stringliteral}{        Returns:}
483 \textcolor{stringliteral}{          [Class(...), ...]}
484 \textcolor{stringliteral}{        """}
485         result = []
486         name\_tokens = []
487         reference = pointer = array = \textcolor{keyword}{False}
488 
489         \textcolor{keyword}{def }AddType(templated\_types):
490             \textcolor{comment}{# Partition tokens into name and modifier tokens.}
491             names = []
492             modifiers = []
493             \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} name\_tokens:
494                 \textcolor{keywordflow}{if} keywords.IsKeyword(t.name):
495                     modifiers.append(t.name)
496                 \textcolor{keywordflow}{else}:
497                     names.append(t.name)
498             name = \textcolor{stringliteral}{''}.join(names)
499             \textcolor{keywordflow}{if} name\_tokens:
500                 result.append(Type(name\_tokens[0].start, name\_tokens[-1].end,
501                                    name, templated\_types, modifiers,
502                                    reference, pointer, array))
503             del name\_tokens[:]
504 
505         i = 0
506         end = len(tokens)
507         \textcolor{keywordflow}{while} i < end:
508             token = tokens[i]
509             \textcolor{keywordflow}{if} token.name == \textcolor{stringliteral}{'<'}:
510                 new\_tokens, new\_end = self.\_GetTemplateEnd(tokens, i+1)
511                 AddType(self.ToType(new\_tokens))
512                 \textcolor{comment}{# If there is a comma after the template, we need to consume}
513                 \textcolor{comment}{# that here otherwise it becomes part of the name.}
514                 i = new\_end
515                 reference = pointer = array = \textcolor{keyword}{False}
516             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{','}:
517                 AddType([])
518                 reference = pointer = array = \textcolor{keyword}{False}
519             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{'*'}:
520                 pointer = \textcolor{keyword}{True}
521             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{'&'}:
522                 reference = \textcolor{keyword}{True}
523             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{'['}:
524                pointer = \textcolor{keyword}{True}
525             \textcolor{keywordflow}{elif} token.name == \textcolor{stringliteral}{']'}:
526                 \textcolor{keywordflow}{pass}
527             \textcolor{keywordflow}{else}:
528                 name\_tokens.append(token)
529             i += 1
530 
531         \textcolor{keywordflow}{if} name\_tokens:
532             \textcolor{comment}{# No '<' in the tokens, just a simple name and no template.}
533             AddType([])
534         \textcolor{keywordflow}{return} result
535 
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_aa6ea82e40cd30e5dfcd471ff144a19cf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classcpp_1_1ast_1_1TypeConverter_aa6ea82e40cd30e5dfcd471ff144a19cf_icgraph}
\end{center}
\end{figure}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classcpp_1_1ast_1_1TypeConverter_abb739f15c6cd0800e07c086c2b30833e}\label{classcpp_1_1ast_1_1TypeConverter_abb739f15c6cd0800e07c086c2b30833e}} 
\index{cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}!namespace\+\_\+stack@{namespace\+\_\+stack}}
\index{namespace\+\_\+stack@{namespace\+\_\+stack}!cpp\+::ast\+::\+Type\+Converter@{cpp\+::ast\+::\+Type\+Converter}}
\subsubsection{\texorpdfstring{namespace\+\_\+stack}{namespace\_stack}}
{\footnotesize\ttfamily cpp.\+ast.\+Type\+Converter.\+namespace\+\_\+stack}



Definition at line 461 of file ast.\+py.



Referenced by cpp.\+ast.\+Ast\+Builder.\+\_\+\+Create\+Variable(), cpp.\+ast.\+Ast\+Builder.\+\_\+\+Get\+Class(), cpp.\+ast.\+Ast\+Builder.\+\_\+\+Get\+Method(), cpp.\+ast.\+Ast\+Builder.\+Generate(), cpp.\+ast.\+Ast\+Builder.\+handle\+\_\+friend(), cpp.\+ast.\+Ast\+Builder.\+handle\+\_\+namespace(), and cpp.\+ast.\+Ast\+Builder.\+handle\+\_\+typedef().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
smacc\+\_\+sm\+\_\+reference\+\_\+library/sm\+\_\+panda\+\_\+moveit/libfranka/3rdparty/googletest/googlemock/scripts/generator/cpp/\hyperlink{ast_8py}{ast.\+py}\end{DoxyCompactItemize}
