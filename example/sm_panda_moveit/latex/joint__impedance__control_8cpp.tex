\hypertarget{joint__impedance__control_8cpp}{}\section{smacc\+\_\+sm\+\_\+reference\+\_\+library/sm\+\_\+panda\+\_\+moveit/libfranka/examples/joint\+\_\+impedance\+\_\+control.cpp File Reference}
\label{joint__impedance__control_8cpp}\index{smacc\+\_\+sm\+\_\+reference\+\_\+library/sm\+\_\+panda\+\_\+moveit/libfranka/examples/joint\+\_\+impedance\+\_\+control.\+cpp@{smacc\+\_\+sm\+\_\+reference\+\_\+library/sm\+\_\+panda\+\_\+moveit/libfranka/examples/joint\+\_\+impedance\+\_\+control.\+cpp}}
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$atomic$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$functional$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$iterator$>$}\newline
{\ttfamily \#include $<$mutex$>$}\newline
{\ttfamily \#include $<$thread$>$}\newline
{\ttfamily \#include $<$franka/duration.\+h$>$}\newline
{\ttfamily \#include $<$franka/exception.\+h$>$}\newline
{\ttfamily \#include $<$franka/model.\+h$>$}\newline
{\ttfamily \#include $<$franka/rate\+\_\+limiting.\+h$>$}\newline
{\ttfamily \#include $<$franka/robot.\+h$>$}\newline
{\ttfamily \#include \char`\"{}examples\+\_\+common.\+h\char`\"{}}\newline
Include dependency graph for joint\+\_\+impedance\+\_\+control.\+cpp\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{joint__impedance__control_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceanonymous__namespace_02joint__impedance__control_8cpp_03}{anonymous\+\_\+namespace\{joint\+\_\+impedance\+\_\+control.\+cpp\}}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T , size\+\_\+t N$>$ }\\std\+::ostream \& \hyperlink{namespaceanonymous__namespace_02joint__impedance__control_8cpp_03_ae1565e96067de4a883d5ca08e7bc5fec}{anonymous\+\_\+namespace\{joint\+\_\+impedance\+\_\+control.\+cpp\}\+::operator$<$$<$} (std\+::ostream \&ostream, const std\+::array$<$ T, N $>$ \&array)
\item 
int \hyperlink{joint__impedance__control_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{joint__impedance__control_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}\label{joint__impedance__control_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}} 
\index{joint\+\_\+impedance\+\_\+control.\+cpp@{joint\+\_\+impedance\+\_\+control.\+cpp}!main@{main}}
\index{main@{main}!joint\+\_\+impedance\+\_\+control.\+cpp@{joint\+\_\+impedance\+\_\+control.\+cpp}}
\subsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$$\ast$}]{argv }\end{DoxyParamCaption})}



Definition at line 41 of file joint\+\_\+impedance\+\_\+control.\+cpp.



References franka\+::\+Robot\+::control(), franka\+::k\+Max\+Torque\+Rate, franka\+::limit\+Rate(), franka\+::\+Robot\+::load\+Model(), franka\+::\+Motion\+Finished(), franka\+::\+Cartesian\+Pose\+::\+O\+\_\+\+T\+\_\+\+EE, franka\+::\+Robot\+::set\+Collision\+Behavior(), and set\+Default\+Behavior().


\begin{DoxyCode}
41                                 \{
42   \textcolor{comment}{// Check whether the required arguments were passed.}
43   \textcolor{keywordflow}{if} (argc != 2) \{
44     std::cerr << \textcolor{stringliteral}{"Usage: "} << argv[0] << \textcolor{stringliteral}{" <robot-hostname>"} << std::endl;
45     \textcolor{keywordflow}{return} -1;
46   \}
47   \textcolor{comment}{// Set and initialize trajectory parameters.}
48   \textcolor{keyword}{const} \textcolor{keywordtype}{double} radius = 0.05;
49   \textcolor{keyword}{const} \textcolor{keywordtype}{double} vel\_max = 0.25;
50   \textcolor{keyword}{const} \textcolor{keywordtype}{double} acceleration\_time = 2.0;
51   \textcolor{keyword}{const} \textcolor{keywordtype}{double} run\_time = 20.0;
52   \textcolor{comment}{// Set print rate for comparing commanded vs. measured torques.}
53   \textcolor{keyword}{const} \textcolor{keywordtype}{double} print\_rate = 10.0;
54 
55   \textcolor{keywordtype}{double} vel\_current = 0.0;
56   \textcolor{keywordtype}{double} angle = 0.0;
57   \textcolor{keywordtype}{double} time = 0.0;
58 
59   \textcolor{comment}{// Initialize data fields for the print thread.}
60   \textcolor{keyword}{struct }\{
61     std::mutex mutex;
62     \textcolor{keywordtype}{bool} has\_data;
63     std::array<double, 7> tau\_d\_last;
64     \hyperlink{structfranka_1_1RobotState}{franka::RobotState} robot\_state;
65     std::array<double, 7> gravity;
66   \} print\_data\{\};
67   std::atomic\_bool running\{\textcolor{keyword}{true}\};
68 
69   \textcolor{comment}{// Start print thread.}
70   std::thread print\_thread([print\_rate, &print\_data, &running]() \{
71     \textcolor{keywordflow}{while} (running) \{
72       \textcolor{comment}{// Sleep to achieve the desired print rate.}
73       std::this\_thread::sleep\_for(
74           std::chrono::milliseconds(static\_cast<int>((1.0 / print\_rate * 1000.0))));
75 
76       \textcolor{comment}{// Try to lock data to avoid read write collisions.}
77       \textcolor{keywordflow}{if} (print\_data.mutex.try\_lock()) \{
78         \textcolor{keywordflow}{if} (print\_data.has\_data) \{
79           std::array<double, 7> tau\_error\{\};
80           \textcolor{keywordtype}{double} error\_rms(0.0);
81           std::array<double, 7> tau\_d\_actual\{\};
82           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < 7; ++i) \{
83             tau\_d\_actual[i] = print\_data.tau\_d\_last[i] + print\_data.gravity[i];
84             tau\_error[i] = tau\_d\_actual[i] - print\_data.robot\_state.tau\_J[i];
85             error\_rms += std::pow(tau\_error[i], 2.0) / tau\_error.size();
86           \}
87           error\_rms = std::sqrt(error\_rms);
88 
89           \textcolor{comment}{// Print data to console}
90           std::cout << \textcolor{stringliteral}{"tau\_error [Nm]: "} << tau\_error << std::endl
91                     << \textcolor{stringliteral}{"tau\_commanded [Nm]: "} << tau\_d\_actual << std::endl
92                     << \textcolor{stringliteral}{"tau\_measured [Nm]: "} << print\_data.robot\_state.tau\_J << std::endl
93                     << \textcolor{stringliteral}{"root mean square of tau\_error [Nm]: "} << error\_rms << std::endl
94                     << \textcolor{stringliteral}{"-----------------------"} << std::endl;
95           print\_data.has\_data = \textcolor{keyword}{false};
96         \}
97         print\_data.mutex.unlock();
98       \}
99     \}
100   \});
101 
102   \textcolor{keywordflow}{try} \{
103     \textcolor{comment}{// Connect to robot.}
104     \hyperlink{classfranka_1_1Robot}{franka::Robot} robot(argv[1]);
105     \hyperlink{examples__common_8cpp_ad0c6e1cb044845ee8a01b5aa1e801a45}{setDefaultBehavior}(robot);
106 
107     \textcolor{comment}{// First move the robot to a suitable joint configuration}
108     std::array<double, 7> q\_goal = \{\{0, -M\_PI\_4, 0, -3 * M\_PI\_4, 0, M\_PI\_2, M\_PI\_4\}\};
109     \hyperlink{classMotionGenerator}{MotionGenerator} motion\_generator(0.5, q\_goal);
110     std::cout << \textcolor{stringliteral}{"WARNING: This example will move the robot! "}
111               << \textcolor{stringliteral}{"Please make sure to have the user stop button at hand!"} << std::endl
112               << \textcolor{stringliteral}{"Press Enter to continue..."} << std::endl;
113     std::cin.ignore();
114     robot.control(motion\_generator);
115     std::cout << \textcolor{stringliteral}{"Finished moving to initial joint configuration."} << std::endl;
116 
117     \textcolor{comment}{// Set additional parameters always before the control loop, NEVER in the control loop!}
118     \textcolor{comment}{// Set collision behavior.}
119     robot.setCollisionBehavior(
120         \{\{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0\}\}, \{\{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0\}\},
121         \{\{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0\}\}, \{\{20.0, 20.0, 18.0, 18.0, 16.0, 14.0, 12.0\}\},
122         \{\{20.0, 20.0, 20.0, 25.0, 25.0, 25.0\}\}, \{\{20.0, 20.0, 20.0, 25.0, 25.0, 25.0\}\},
123         \{\{20.0, 20.0, 20.0, 25.0, 25.0, 25.0\}\}, \{\{20.0, 20.0, 20.0, 25.0, 25.0, 25.0\}\});
124 
125     \textcolor{comment}{// Load the kinematics and dynamics model.}
126     \hyperlink{classfranka_1_1Model}{franka::Model} model = robot.loadModel();
127 
128     std::array<double, 16> initial\_pose;
129 
130     \textcolor{comment}{// Define callback function to send Cartesian pose goals to get inverse kinematics solved.}
131     \textcolor{keyword}{auto} cartesian\_pose\_callback = [=, &time, &vel\_current, &running, &angle, &initial\_pose](
132                                        \textcolor{keyword}{const} \hyperlink{structfranka_1_1RobotState}{franka::RobotState}& robot\_state,
133                                        \hyperlink{classfranka_1_1Duration}{franka::Duration} period) -> 
      \hyperlink{classfranka_1_1CartesianPose}{franka::CartesianPose} \{
134       \textcolor{comment}{// Update time.}
135       time += period.toSec();
136 
137       \textcolor{keywordflow}{if} (time == 0.0) \{
138         \textcolor{comment}{// Read the initial pose to start the motion from in the first time step.}
139         initial\_pose = robot\_state.O\_T\_EE\_c;
140       \}
141 
142       \textcolor{comment}{// Compute Cartesian velocity.}
143       \textcolor{keywordflow}{if} (vel\_current < vel\_max && time < run\_time) \{
144         vel\_current += period.toSec() * std::fabs(vel\_max / acceleration\_time);
145       \}
146       \textcolor{keywordflow}{if} (vel\_current > 0.0 && time > run\_time) \{
147         vel\_current -= period.toSec() * std::fabs(vel\_max / acceleration\_time);
148       \}
149       vel\_current = std::fmax(vel\_current, 0.0);
150       vel\_current = std::fmin(vel\_current, vel\_max);
151 
152       \textcolor{comment}{// Compute new angle for our circular trajectory.}
153       angle += period.toSec() * vel\_current / std::fabs(radius);
154       \textcolor{keywordflow}{if} (angle > 2 * M\_PI) \{
155         angle -= 2 * M\_PI;
156       \}
157 
158       \textcolor{comment}{// Compute relative y and z positions of desired pose.}
159       \textcolor{keywordtype}{double} delta\_y = radius * (1 - std::cos(angle));
160       \textcolor{keywordtype}{double} delta\_z = radius * std::sin(angle);
161       \hyperlink{classfranka_1_1CartesianPose}{franka::CartesianPose} pose\_desired = initial\_pose;
162       pose\_desired.\hyperlink{classfranka_1_1CartesianPose_a406e53e3d8fe594a11888f516eb4bf7d}{O\_T\_EE}[13] += delta\_y;
163       pose\_desired.\hyperlink{classfranka_1_1CartesianPose_a406e53e3d8fe594a11888f516eb4bf7d}{O\_T\_EE}[14] += delta\_z;
164 
165       \textcolor{comment}{// Send desired pose.}
166       \textcolor{keywordflow}{if} (time >= run\_time + acceleration\_time) \{
167         running = \textcolor{keyword}{false};
168         \textcolor{keywordflow}{return} \hyperlink{namespacefranka_a20791f7142d78bbbe3c957cc66a23ade}{franka::MotionFinished}(pose\_desired);
169       \}
170 
171       \textcolor{keywordflow}{return} pose\_desired;
172     \};
173 
174     \textcolor{comment}{// Set gains for the joint impedance control.}
175     \textcolor{comment}{// Stiffness}
176     \textcolor{keyword}{const} std::array<double, 7> k\_gains = \{\{600.0, 600.0, 600.0, 600.0, 250.0, 150.0, 50.0\}\};
177     \textcolor{comment}{// Damping}
178     \textcolor{keyword}{const} std::array<double, 7> d\_gains = \{\{50.0, 50.0, 50.0, 50.0, 30.0, 25.0, 15.0\}\};
179 
180     \textcolor{comment}{// Define callback for the joint torque control loop.}
181     std::function<franka::Torques(const franka::RobotState&, franka::Duration)>
182         impedance\_control\_callback =
183             [&print\_data, &model, k\_gains, d\_gains](
184                 \textcolor{keyword}{const} \hyperlink{structfranka_1_1RobotState}{franka::RobotState}& state, 
      \hyperlink{classfranka_1_1Duration}{franka::Duration} \textcolor{comment}{/*period*/}) -> \hyperlink{classfranka_1_1Torques}{franka::Torques} \{
185       \textcolor{comment}{// Read current coriolis terms from model.}
186       std::array<double, 7> coriolis = model.coriolis(state);
187 
188       \textcolor{comment}{// Compute torque command from joint impedance control law.}
189       \textcolor{comment}{// Note: The answer to our Cartesian pose inverse kinematics is always in state.q\_d with one}
190       \textcolor{comment}{// time step delay.}
191       std::array<double, 7> tau\_d\_calculated;
192       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < 7; i++) \{
193         tau\_d\_calculated[i] =
194             k\_gains[i] * (state.q\_d[i] - state.q[i]) - d\_gains[i] * state.dq[i] + coriolis[i];
195       \}
196 
197       \textcolor{comment}{// The following line is only necessary for printing the rate limited torque. As we activated}
198       \textcolor{comment}{// rate limiting for the control loop (activated by default), the torque would anyway be}
199       \textcolor{comment}{// adjusted!}
200       std::array<double, 7> tau\_d\_rate\_limited =
201           \hyperlink{namespacefranka_a77e127a920da5b0ad29877ec3ff29f15}{franka::limitRate}(\hyperlink{namespacefranka_a6c1a0e9a5e1f375d2aad61edac907d4e}{franka::kMaxTorqueRate}, tau\_d\_calculated
      , state.tau\_J\_d);
202 
203       \textcolor{comment}{// Update data to print.}
204       \textcolor{keywordflow}{if} (print\_data.mutex.try\_lock()) \{
205         print\_data.has\_data = \textcolor{keyword}{true};
206         print\_data.robot\_state = state;
207         print\_data.tau\_d\_last = tau\_d\_rate\_limited;
208         print\_data.gravity = model.gravity(state);
209         print\_data.mutex.unlock();
210       \}
211 
212       \textcolor{comment}{// Send torque command.}
213       \textcolor{keywordflow}{return} tau\_d\_rate\_limited;
214     \};
215 
216     \textcolor{comment}{// Start real-time control loop.}
217     robot.control(impedance\_control\_callback, cartesian\_pose\_callback);
218 
219   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} \hyperlink{structfranka_1_1Exception}{franka::Exception}& ex) \{
220     running = \textcolor{keyword}{false};
221     std::cerr << ex.what() << std::endl;
222   \}
223 
224   \textcolor{keywordflow}{if} (print\_thread.joinable()) \{
225     print\_thread.join();
226   \}
227   \textcolor{keywordflow}{return} 0;
228 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{joint__impedance__control_8cpp_a3c04138a5bfe5d72780bb7e82a18e627_cgraph}
\end{center}
\end{figure}
