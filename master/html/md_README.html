<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SMACC: Travis CI:</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMACC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Travis CI: </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table class="doxtable">
<tr>
<th>ROS Distro </th><th>Travis Build Status </th><th>Documentation  </th></tr>
<tr>
<td>Indigo </td><td><div class="image">
<img src="https://travis-ci.com/reelrbtx/SMACC.svg?branch=indigo-devel" />
</div>
 </td><td><a href="https://reelrbtx.github.io/SMACC/indigo-devel/html/md_README.html">doxygen</a> </td></tr>
<tr>
<td>Kinetic </td><td><div class="image">
<img src="https://travis-ci.com/reelrbtx/SMACC.svg?branch=kinetic-devel" />
</div>
 </td><td><a href="https://reelrbtx.github.io/SMACC/kinetic-devel/html/md_README.html">doxygen</a> </td></tr>
<tr>
<td>Melodic </td><td><div class="image">
<img src="https://travis-ci.com/reelrbtx/SMACC.svg?branch=melodic-devel" />
</div>
 </td><td><a href="https://reelrbtx.github.io/SMACC/melodic-devel/html/md_README.html">doxygen</a> </td></tr>
<tr>
<td>Master </td><td><div class="image">
<img src="https://travis-ci.com/reelrbtx/SMACC.svg?branch=master" />
</div>
 </td><td><a href="https://reelrbtx.github.io/SMACC_Documentation/master/html/namespaces.html">doxygen</a> </td></tr>
</table>
<h2>Docker Containers</h2>
<p><a href="https://hub.docker.com/r/pabloinigoblasco/smacc/"></a> <a href="https://hub.docker.com/r/pabloinigoblasco/smacc/"></a> <a href="https://registry.hub.docker.com/pabloinigoblasco/smacc/"></a></p>
<h1>SMACC</h1>
<p>SMACC is an event-driven, asynchronous, behavioral state machine library for real-time ROS (Robotic Operating System) applications written in C++, designed to allow programmers to build robot control applications for multicomponent robots, in an intuitive and systematic manner.</p>
<p>SMACC is inspired by the <a href="http://wiki.ros.org/smach">SMACH ROS package</a> and it is built on top of <a href="https://www.boost.org/doc/libs/1_53_0/libs/statechart/doc/index.html">Boost StateChart library</a>.</p>
<p>Probably the greatest strength of SMACC is that it offers out-of-the-box reference state machines, (found in the folder <a href="https://github.com/reelrbtx/SMACC/tree/master/smacc_sm_reference_library">sm_reference_library</a>) that you can use, test, hack, and customize to quickly get your application up and running, while also knowing that the library supports advanced functionalities that are practically universal among actual working robots.</p>
<h2>Features</h2>
<ul>
<li>***Powered by ROS:*** SMACC has been developed specifically to work with ROS. It is a c++ ros package that can be imported from any end-user application package.</li>
<li>***Written in C++:*** Until now, ROS has lacked a library to develop task-level state machines in C++. Although libraries have been developed in scripting languages such as python, these are unsuitable for real-world industrial evironments where real-time requirements are demanded.</li>
<li>***Static State Machine Checking:*** SMACC inherits this from the Boost Statechart library which helps the developer to check the consistency of the state machine at compile time (instead of runtime).</li>
<li>***Component based architecture:*** SMACC has built-in funcionality provided inside SMACC Components that can be dynamically imported at runtime and stored in the local machine. The states only access those components they are concerned with. This enables the SMACC based application to extend or improve the runtime behavior of the system.</li>
</ul>
<h2>SMACC applications</h2>
<p>From it's inception, SMACC was written to support the programming of multi-component, complex robots. If your project involves small, solar-powered insect robots, that simply navigate towards a light source, then SMACC might not be the right choice for you. But if you are trying to program a robot with a mobile base, a robotic arm, a gripper, two lidar sensors, a gps transceiver and an imu, then you've come to the right place.</p>
<h2>ROS Integration</h2>
<ul>
<li>***Intensive use of ROS Action***. SMACC translates Action server events (Result callbacks, Feedback callbacks, etc.) into statechart events. To learn more about this, check the sections Shared Resources and SMACC Architecture.</li>
<li>***Powerful access to ROS Parameters***. Each SMACC state automatically creates a ros::NodeHandle automatically named according to the SMACC state hierarchy (see more in section Usage Examples - Ros parameters)</li>
<li>***ROS Navigation built-in funcionality***. SMACC extends the ROS navigation stack in a high level way. It provides specialized navigation planners (for the ROS Navigation Stack) that navigate only using pure spinning motions and straight motions. Implements some mechanism to perform motions recording the path and undoing them later. These can be very useful in some industrial applications where the knowledge or certainty on the environment is higher (ros planners are focused on cluttered and dynamic environments).</li>
</ul>
<h2>Future Work</h2>
<ul>
<li>undoing paths chunks by state (store the different chunks of the path according to its state in a stack)</li>
<li>code generation based on uml diagrams</li>
<li>improving backwards planners for non linear paths</li>
</ul>
<h2>Development methodology</h2>
<p>SMACC also defines a development methodology where State Machine nodes only contain the task-level logic, that is, the high level behavior of the robot system in some specific application.</p>
<p>SMACC applications have low level coupling with other software components of the robot system. SMACC code is recomended to interact with the rest of components the robot system via ROS Action Servers and <b>Smacc Action Plugins</b>.</p>
<p>The proposed methdology split the states into 2 or more statechart orthogonal lines that comunicate to each other via events. The orthogonal line 0 is tipically for the mobile robot navigation. The second orthogonal line and ahead are used for tools (manipulators, grippers or other custom tools).</p>
<div class="image">
<img src="https://github.com/reelrbtx/SMACC/blob/master/documentation/SMACC-Containers-3.jpg"  width="450" align="center"/>
</div>
 <h2>Internal Architecture</h2>
<p>SMACC State Machines are boost::statechart AsynchronousStateMachines that can work in a multi-threaded application. In SMACC State Machines are two main components that work concurrently in two different threads:</p>
<ul>
<li>***Signal Detector***. It is able to handle the action client components communication with action servers and translate them to statechart events</li>
<li>***State Machine***. It is the end-user code of the state machine itself.</li>
</ul>
<div class="image">
<img src="http://smacc.ninja/wp-content/uploads/2018/09/SMACC-Node-Map-2-2-1.jpg"  width="450" align="center"/>
</div>
 <h1>Tutorial</h1>
<p>SMACC states inherits from boost::statechart:State so that you can learn the full potential of SMACC states also diving in the statechart documentation. However, the following examples briefly show how you create define SMACC states and how you would usually use them.</p>
<h2>Getting Started</h2>
<p>The easiest way to get started is by selecting one of the state machines in our reference library, and then hacking it to meet your needs.</p>
<p>Each state machine in the reference library comes with it's own README.md file, which contains the appropriate operating instructions, so that all you have to do is simply copy &amp; paste some commands into your terminal.</p>
<h2>Anatomy of a simple SMACC State</h2>
<p>For the previous state machine, this would be the initial SMACC State. It also follows the Curiously recurrent template pattern. However, for Smacc states, the second template parameters is the so called "Context", for this simple case, the context is the StateMachine type itself. However, that could also be other State (in a nexted-substate case) or an orthogonal line.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ToolSimpleState</div><div class="line">    : <a class="code" href="classSmaccState.html">SmaccState</a>&lt;ToolSimpleState, SimpleStateMachine&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="keyword">using</span> SmaccState::SmaccState;</div><div class="line">  <span class="keywordtype">void</span> onEntry()</div><div class="line">  {</div><div class="line">    ROS_INFO(<span class="stringliteral">&quot;Entering ToolSimpleState&quot;</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="odom__tracker__node_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">  <span class="comment">// initialize the ros node</span></div><div class="line">  ros::init(argc, argv, <span class="stringliteral">&quot;example1&quot;</span>);</div><div class="line">  ros::NodeHandle nh;</div><div class="line"></div><div class="line">  smacc::run&lt;SimpleStateMachine&gt;();</div><div class="line">}</div></div><!-- fragment --><p> According to the UML statchart standard, things happens essencially when the system enters in the state, when the system exits the state and when some event is triggered. The two first ones are shown in this example. The c++ Constructor code is the place you have to write your "entry code", the destructor is the place you have to write your "exit code". The constructor parameter (my_context) is a reference to the context object (in this case the state machine). This kind of constructor may be verebosy, but is required to implement the rest of SMACC tasks and always follows the same pattern.</p>
<h2>Simple State Transition on Action Result Event</h2>
<p>According to the UML state machines standard, transitions between states happen on events. In SMACC events can be implemented by the user or happen when Action Results callbacks and Action Feedback callbacks happen. In the following example we extend the previous example to transit to another state 'ExecuteToolState' when the move_base action sever returns a Result.</p>
<div class="image">
<img src="https://raw.githubusercontent.com/brettpac/SMACC/master/documentation/action_result_transition.png"  width="450"/>
</div>
 <p>The following would be the code to implement the diagram shown above.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Navigate : <a class="code" href="classSmaccState.html">SmaccState</a>&lt;Navigate, SimpleStateMachine&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// With this line we specify that we are going to react to any EvActionResult event</span></div><div class="line">  <span class="comment">// generated by SMACC when the action server provides a response to our request</span></div><div class="line">  <span class="keyword">typedef</span> mpl::list&lt;sc::transition&lt;EvActionResult&lt;SmaccMoveBaseActionClient::Result&gt;, ExecuteToolState&gt;&gt; reactions;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> SmaccState::SmaccState;</div><div class="line">  <span class="keywordtype">void</span> onEntry()</div><div class="line">  {</div><div class="line">   [...]</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>ExecuteToolState : <a class="code" href="classSmaccState.html">SmaccState</a>&lt;ExecuteToolState, SimpleStateMachine&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> SmaccState::SmaccState;</div><div class="line">    <span class="keywordtype">void</span> onEntry()</div><div class="line">    {</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h2>Adding ROS Parameters to Smacc States</h2>
<p>The SMACC states can be configured from the ros parameter server based on their hierarchy and their class name. It is responsability of the user not to have two different state names at the same level (even if the namespace is distinct since the namespace is trimmed for parameters)</p>
<p>For example, imagine a StateMachine to move the mobile robot initially to some initial position, and then moving it to some other position relative to the initial position. You could put the navigation parameters in a ros configuration yaml file like this (and avoid hardcoding):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;MyStateMachine:</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    State1: #Go to some initial position</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        NavigationOrthogonalLine:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            Navigate:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                start_position_x: 3</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                start_position_y: 0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    State2: #Go to some initial position</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        NavigationOrthogonalLine:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;            Navigate:</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                initial_orientation_index: 0 # the initial index of the linear motion (factor of angle_increment_degrees)</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                angle_increment_degree: 90    # the increment of angle between to linear motions</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                linear_trajectories_count: 2  # the number of linear trajectories of the radial </div></div><!-- fragment --><p>Then, the c++ code for the State MyStateMachine/State1/NavigationOrthogonalLine/Navigate could contain the following parameter reading funcionality:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Navigate : <a class="code" href="classSmaccState.html">SmaccState</a>&lt;Navigate, NavigationOrthogonalLine&gt; </div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> SmaccState::SmaccState;</div><div class="line">  <span class="keywordtype">void</span> onEntry()</div><div class="line">  {</div><div class="line">      geometry_msgs::Point p;</div><div class="line">      param(<span class="stringliteral">&quot;start_position_x&quot;</span>, p.x, 0);</div><div class="line">      param(<span class="stringliteral">&quot;start_position_y&quot;</span>, p.y, 0);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The param template method reads from the parameters server delegating to the method defined ros::NodeHandle handle does but already located at the exact point in the parameter name hierarchy associated to this state. SMACC is also able have methods getParam and setParam that are delegated to ros::NodeHandle in the same way. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
